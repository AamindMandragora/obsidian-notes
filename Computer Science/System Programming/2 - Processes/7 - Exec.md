To make the child process execute another program, we can use one of the family of `exec` functions after forking, which replace the process image (static resource / layout of the process) with that of the specified program. Therefore, any lines of code after the `exec` call will not be run if it was successful, which is why we spawn a child process to call it for the parent. The naming schemes of the functions follow the following rules: e (env array explicitly passed), l (args passed individually as a comma-delimited NULL-terminated list), p (uses PATH to find the executable), and v (args passed as a NULL-terminated array of pointers). Remember that the first argument will be the executable name, so it will show up twice in the `exec` call.
# POSIX Exec Details

File descriptors, signal masks, and the pending signal set are preserved after an `exec`, while signal handlers are not. The only exception is if the file descriptor has the close-on-exec flag (`O_CLOEXEC`). Environment variables are also preserved unless otherwise specified. The OS may open `stdin`, `stdout`, `stderr` if they are closed after exec, but will usually leave them closed. The executed process shares a PID, parent, user, and working directory as the process that called it.
# Shortcuts

The `system` function takes an executable as an argument and bundles the fork-exec-wait calls. This means it's a blocking call, so the parent can't continue until the process it started exits. Also, `system` creates a shell to run the process instead of just directly wrapping `exec`, which adds overhead. While it's great for easy commands, it is limiting for more complex or subtle problems, so fork-exec-wait is the way to go. Also, it can be a huge security risk if someone passes in `; sudo su` and escalates their privilege.