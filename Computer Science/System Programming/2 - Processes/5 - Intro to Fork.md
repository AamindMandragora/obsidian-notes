# A Word of Warning

Process forking is powerful and dangerous, capable of bringing down a system. We can limit the maximum number of processes a user can have by running `ulimit -u 400`, which will unfortunately ban the user from implicitly calling `fork()` in the shell to run `killall`. You could create another shell under a different user and kill processes from there to avoid this. You could also use `exec` to kill all the processes or reboot the system, but there's only one shot. When testing code that calls `fork()`, make sure you have root and/or physical access to the machine, and remember that `kill -9 -1` will save you in emergencies,
# Fork Functionality

The `fork` system call clones the current process to create a child process, which contains a duplicated copy of the original process's state. The child process will then execute every line after the `fork`, as does the parent, and in older UNIX systems, the entire address space of the parent process was directly copied, while modern systems perform a copy-on-write. Since some commands, like `printf`, buffer their outputs, if you don't `fflush` to standard out, that text can be copied by the `fork()`, To write code that's different for the parent and child process, check the return value of `fork`. `-1` means there was a failure and we should check `errno` to see exactly what, `0` means that we're operating as the child process, and a positive integer (the child process's PID) means we're in the parent process.

Child processes don't need `fork` to return their PPID as they can just call `getppid()`, which works as children can only have one parent according to POSIX, but parents can have many children and need the `fork` return value to figure out which it wants to use.

The behavior of `fork` inspired *sleepsort*, which is written below:

```c
int main(int c, char **v) {
	while (--c > 1 && !fork());
	int val = atoi(v[c]);
	sleep(val);
	printf("%d\n", val);
	return 0;
}
```

This code creates a process for every single element in the `char` array `v`, converts it to an integer and sleeps for that long, then finally prints out that element. Since the OS schedules processes somewhat in parallel, this code effectively makes every element start sleeping at the same time, so they're printed in ascending order. Unfortunately, that means sleepsort isn't actually $O(n)$.
# Fork Bomb

A fork bomb is when there's an attempt to create an infinite amount of processes, which can bring systems to a near-standstill as it scrambles to allocate CPU time and memory to all of them. System administrators can set limits to the number of processes per user, and a program can limit the number of child processes created by using `setrlimit()`. While some are easy to spot, like calling `fork` in a `while(1)` loop, others are more complicated. For example, if an `exec` call fails, the child process will continue to run until it hits an `exit` or `return`. This is why we must always remember to catch an error and `return` from the child process as soon as we're done with it.
# Signals

We know hardware has interrupts, generated by peripheral devices (mouse, keyboard, disk) that tells the CPU an event has happened that needs immediate attention and the CPU must drop whatever it's doing to address it. The software equivalent is called a signal, and we already know some of them, like SIGSEGV (segfault) and SIGINT (interrupt). If no handler is defined for that specific signal, we fall back to the default handler, like terminating the program or ignoring the signal. We can assign handlers to signals by calling `signal(SIGINT, handler)` in main, where SIGINT is our chosen signal to catch and handler is a function that takes an `int signum` and returns `void`. That `signum` is useful to differentiate between signals if `handler` catches more than one.

Signals have four stages in their life cycle: being generated by the process, waiting for the kernel to deliver it, being blocked, and finally getting delivered. Each stage is not instantaneous, which means that it's bad practice to explicitly send them between processes in your program, as there's no time frame where they're guaranteed to be sent by. Fork and exec also interact with signals based on what stage they're in.
# POSIX Fork Details

POSIX defines fork to return a non-negative integer on success, give the child process all of the parent's open file descriptors, read-only memory addresses, signal handlers, current working directory, and environment variables (the last three of which can be changed) but does not give the child any pending signals. The child process will be created with a single thread, and if a program sets up certain regions of memory, they can be shared between processes. The parent is notified via SIGCHLD when its child process finishes, but not vice versa.
# Fork and FILEs

A **file description** is the struct that a file descriptor points to, and for our purposes will represent a file on a filesystem and contain paths, how far the descriptor has read into the file, etc. When a process is forked, only the file descriptor is cloned, not the description. If we call `open` before we fork, the two processes will read different parts of the file as the description, including the read pointer, is shared.

To prepare a file descriptor, we must check if it is a file descriptor or an unbuffered `FILE*`. If not, it must be open for reading and read fully. Otherwise, the `FILE*` must be `fflused` or closed. It cannot be active in both the parent and the child process at the same time, or else the whole application's behavior becomes undefined. If the parent and child need to perform asynchronously, we can use the double fork method, where we fork, close the file in the child, fork again, and perform asynchronous work while the parent process waits on the first child with the file still open.