# Keywords

`break` is a keyword used to jump to the end of a case statement or exit out of the inner-most looping statement.

`const` is a variable modifier that tells the compiler that this data shouldn't be changed and code that does that shouldn't compile. It makes whatever is directly to its left constant, so `const int* x` is a pointer to a constant int while `int* const y` is a constant pointer to a (modifiable) int. Of course, there are ways to get around this, as the only memory you can't write to is that protected by the system.

`continue` is a keyword used to skip the rest of the loop body and start from the next iteration.

`do {} while();` is another loop construct used to execute the body before checking the condition.

`enum` declares a type that can take on many finite values that each map to integral constants (either defined or autogenerated).

`extern`tells the compiler that a variable will be defined in another place and missing variable errors for that specific variable should be ignored during compilation.

`for` is a keyword that allows you to iterate with initialization, invariant, and update conditions, equivalent to a while loop but with different syntax. In the past, declaring variables in the initialization block was illegal, but that has been resolved by the recent standards. The order of evaluation for a for loop is: initialization, invariant check, body, update, return to invariant and repeat.

`goto` is a keyword that enables conditional jumps, and shouldn't be used unless in a kernel context as it greatly reduces readability.

`if`, `else if`, and `else` are control flow keywords that abstract away branching on conditions.

`inline` is a function modifier thattells the compiler that it's okay to just substitute the function body into the calling function instead of going through the C function call procedure. Usually the compiler can figure out when to do that on its own.

`restrict` is a parameter modifier that tells the compiler that this particular memory region shouldn't overlap with any other parameter's memory region and tells users that behavior is undefined otherwise.

`return` is a control flow operator that exits the function with a value of whatever return type the function was, or nothing if it was `void`.

`signed` is a rarely-used modifier that forces a type to be signed (already default) instead of unsigned (uses the `unsigned`modifier), but doesn't change the size of the datatype

`sizeof` returns the number of bytes contained by the argument passed inside and is evaluated at compile-time, which means for structs that require linking to another file containing the definition, `sizeof(struct)` will cause a compilation error. If we call `sizeof` on a static array, the compiler will figure out the actual size of it instead of the size of the pointer.

`static` is a type specifier that states that the scope of global variables or function declarations are limited to the file and that the lifetime of a function variable is extended to that of the program and is shared between function calls.

`struct` is a keyword that combines multiple types into a new contiguous block of memory that the specific elements can be independently accessed from (there might be padding).

`switch` statements are basically jump statements with multiple cases, denoted by `case` (there's sometimes a `default`). Once execution starts in a case, it keeps falling through until it hits a break.

`typedef` declares an alias for a type or struct.

`union` is a new type specifier that denotes a single piece of memory occupied by several variables (like a struct of four chars and an int).

`unsigned` forces a primitive integer type to be stored as an unsigned binary number, doesn't change the size of the datatype

`void` means that a function or parameter accepts or returns no value or parameter, or when defining a pure memory address that doesn't have an underlying type but can be given one at any time.

`volatile` is a compiler keyword telling it to not optimize the value of a certain variable out.

`while` represents the traditional while loop with an invariant.
# C Data Types

`char` represents one byte of data exactly, but the number of bits might vary depending on the system (almost always 8, which the rest of the types will assume). All data must be aligned on a boundary (meaning the address is divisible by the size), so we can't use bits in between two addresses

`short` or `short int` must be at least two bytes and is therefore aligned on a two byte boundary

`int` must be at least two bytes and is aligned to a two byte boundary, but will be four bytes on most machines

`long` or `long int` must be at least four bytes, but can be eight on some machines

`long long` must be at least eight bytes and is aligned to an eight byte boundary

`float` represents a single precision floating point number specified by IEEE-754, and is four bytes large

`double` is an IEEE-754 double precision floating point number aligned to eight byte boundaries

`[u]int(width)_t` is a fixed width integer type defined in `stdint.h`, where the `u` is optional and denotes unsigned, and the width can be filled in with 8, 16, 32, or 64.
# Operators

`[]` is the subscript operator and, when applied, translates to `a[n] == *(a + n)` where `n` is an integral type and `a` is a pointer.

`->` is the struct dereference (arrow) operator, which accesses an element of a struct through its pointer.

`.` is the struct reference operator, which accesses an element of a struct through its object.

`+/-` are the unary plus and minus operators, either keeping or negating the sign of the numeric type they modify.

`*` is the dereference operator which reads and/or writes the element being pointed to.

`&` is the address-of operator which returns the address of an element.

`++/--` are the increment and decrement operators, which can increase and decrease an element by one, respectively, and can be used as either a prefix or a postfix.

`{+, -, *, %, /}` are the arithmetic binary operators and work exactly as expected for two numeric types. If the left operand is a pointer, then only plus and minus are defined and pointer arithmetic rules are enforced.

`>>/<<` are the bit shift operators, and both operands must be integer types (the second one cannot be signed negative). Shifting by the word size results in undefined behavior.

`{<=, >=, <, >, ==, !=}` are relational operators that work exactly as expected.

`&&/&` are the logical and bitwise AND operators.

`||/|` are the logical and bitwise OR operators.

`!/~` are the logical and bitwise NOT operators.

`?:` is the ternary operator, which evaluates a boolean and returns the element before the colon if true and after if false.

`,` is the comma operator, which evaluates each statement it delimits in sequence and then returns the last one.