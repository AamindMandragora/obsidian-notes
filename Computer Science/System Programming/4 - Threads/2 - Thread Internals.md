Every function allocates some automatic variables to the stack by moving the stack pointer down and creating space. On return, we can move the stack pointer back up to free that space, which explains why returning from a function is quick. We can save the old stack pointer value on the stack as well.

When multi-threading, there are multiple stacks within a single address space, and the `pthread` library allocates space for each using the `clone` system call. Each program starts with a single thread, and we can create more using `pthread_create`, passing in a pointer to a `pthread_t`to create a unique identifier and a pointer to a function that the thread will start from. Each thread can see the heap, global variables, and program code, which means more than one CPU can work on the program at once. The OS will assign CPU cores to active threads as well as possible, automatically switching between them if there are more threads than cores.